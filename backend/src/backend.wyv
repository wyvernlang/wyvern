require stdout

import wyvern.BackendSupport
import wyvern.collections.list
import wyvern.option
import wyvern.runtime

import util
import wyb_ast
import rename
import emit_js

type List = list.List
type Option = option.Option

def typeDescFromProtobuf(protobufTypeDesc: Dyn): wyb_ast.TypeDesc
    var ext: Option = option.None[String]()
    if (protobufTypeDesc.hasExtends())
        ext = option.Some[String](protobufTypeDesc.getExtends())
    val t = protobufTypeDesc.getType()
    //TODO: tag
    wyb_ast.TypeDesc(ext, typeFromProtobuf(t), option.None[wyb_ast.Tag]())

def typeFromProtobuf(protobufType: Dyn): wyb_ast.Type
    if (protobufType.hasCompoundType())
            val ct = protobufType.getCompoundType()
            val b = typeFromProtobuf(ct.getBase())
            val selfName = ct.getSelfName()
            // TODO: real declTypes
            val dts = list.make[wyb_ast.DeclType]()
            // TODO: real statefulness
            val stateful = false
            wyb_ast.CompoundType(b, selfName, dts, stateful)
        elif (protobufType.hasPath())
            val p = protobufType.getPath()
            wyb_ast.TypePath(p)
        elif (protobufType.hasSimpleType())
            //TODO: real simple types
            wyb_ast.TTop()



def statementFromProtobuf(protobufStatement: Dyn): wyb_ast.Statement
    if (protobufStatement.hasDeclaration())
            val d = protobufStatement.getDeclaration()
            wyb_ast.D(declarationFromProtobuf(d))
        elif (protobufStatement.hasExpression())
            val e = protobufStatement.getExpression()
            wyb_ast.E(expressionFromProtobuf(e))
        else
            runtime.fail("Invalid proto statement type")

def argumentFromProtobuf(protobufArgument: Dyn): wyb_ast.Argument
    val t = typeFromProtobuf(protobufArgument.getType())
    wyb_ast.Argument(protobufArgument.getVariable(), t)

def declarationFromProtobuf(protobufDeclaration: Dyn): wyb_ast.Declaration
    if (protobufDeclaration.hasVariableDeclaration())
            val d = protobufDeclaration.getVariableDeclaration()
            val dt = d.getDeclarationType()
            val v = d.getVariable()
            val t = typeFromProtobuf(d.getType())
            val e = expressionFromProtobuf(d.getInitializer())
            wyb_ast.VariableDeclaration(dt, v, t, e)
        elif (protobufDeclaration.hasMethodDeclaration())
            val md = protobufDeclaration.getMethodDeclaration()
            val mn = md.getMethodName()
            val al: List[Dyn] = BackendSupport.dynToList(md.getArgumentsList())
            val args = al.map[wyb_ast.Argument]((a: Dyn) => argumentFromProtobuf(a))
            val rt = typeFromProtobuf(md.getReturnType())
            val body = expressionFromProtobuf(md.getBody())
            wyb_ast.MethodDeclaration(mn, args, rt, body)
        elif (protobufDeclaration.hasTypeDeclaration())
            val td = protobufDeclaration.getTypeDeclaration()
            val n = td.getName()
            val t = typeDescFromProtobuf(td.getTypeDesc())
            wyb_ast.TypeDeclaration(n, t)
        else
            runtime.fail("Invalid proto declaration type")

def expressionFromProtobuf(protobufExpression: Dyn): wyb_ast.Expression
    if (protobufExpression.hasVariable())
            val v = protobufExpression.getVariable()
            wyb_ast.Var(v)
        elif (protobufExpression.hasLiteral())
            val l = protobufExpression.getLiteral()
            if (l.hasIntegerLiteral())
                    wyb_ast.IntegerLiteral(BackendSupport.byteStringToInt(l.getIntegerLiteral()))
                elif (l.hasStringLiteral())
                    wyb_ast.StringLiteral(l.getStringLiteral())
                elif (l.hasBooleanLiteral())
                    wyb_ast.BooleanLiteral(l.getBooleanLiteral())
                elif (l.hasFloatLiteral())
                    wyb_ast.FloatLiteral(l.getFloatLiteral())
                else
                    runtime.fail("Unsupported literal")
        elif (protobufExpression.hasNewExpression())
            val n = protobufExpression.getNewExpression()
            val t = typeFromProtobuf(n.getType())
            val v = n.getSelfName()
            val dl: List[Dyn] = BackendSupport.dynToList(n.getDeclarationsList())
            val ds = dl.map[wyb_ast.Declaration]((d: Dyn) => declarationFromProtobuf(d))
            wyb_ast.NewExpression(t, v, ds)
        elif (protobufExpression.hasCallExpression())
            val c = protobufExpression.getCallExpression()
            val receiver = expressionFromProtobuf(c.getReceiver())
            val method = c.getMethod()
            val al: List[Dyn] = BackendSupport.dynToList(c.getArgumentsList())
            val arguments = al.map[wyb_ast.Expression]((e: Dyn) => expressionFromProtobuf(e))
            wyb_ast.CallExpression(receiver, method, arguments)
        elif (protobufExpression.hasStaticCallExpression())
            val sc = protobufExpression.getStaticCallExpression()
            val receiver = expressionFromProtobuf(sc.getReceiver())
            val method = sc.getMethod()
            val receiverType = sc.getReceiverType()
            val al: List[Dyn] = BackendSupport.dynToList(sc.getArgumentsList())
            val arguments = al.map[wyb_ast.Expression]((e: Dyn) => expressionFromProtobuf(e))
            wyb_ast.StaticCallExpression(receiver, receiverType, method, arguments)
        elif (protobufExpression.hasSequenceExpression())
            val se = protobufExpression.getSequenceExpression()
            val sl: List[Dyn] = BackendSupport.dynToList(se.getStatementsList())
            val statements = sl.map[wyb_ast.Statement]((s: Dyn) => statementFromProtobuf(s))
            wyb_ast.SequenceExpression(statements)
        elif (protobufExpression.hasMatchExpression())
            val me = protobufExpression.getMatchExpression()
            val e = expressionFromProtobuf(me.getExpression())
            var elseClause: Option[wyb_ast.Expression] = option.None[wyb_ast.Expression]()
            if (me.hasElse())
                elseClause = option.Some(expressionFromProtobuf(me.getElse()))
            val ml: List[Dyn] = BackendSupport.dynToList(me.getArmsList())
            val arms = ml.map[wyb_ast.MatchArm]((s: Dyn) => matchArmFromProtobuf(s))
            wyb_ast.MatchExpression(e, arms, elseClause)
        elif (protobufExpression.hasAccessExpression())
            val ae = protobufExpression.getAccessExpression()
            val e = expressionFromProtobuf(ae.getExpression())
            val f = ae.getField()
            wyb_ast.AccessExpression(e, f)
        elif (protobufExpression.hasAssignmentExpression())
            val ae = protobufExpression.getAssignmentExpression()
            val e = expressionFromProtobuf(ae.getExpression())
            val f = ae.getField()
            val v = expressionFromProtobuf(ae.getValue())
            wyb_ast.AssignmentExpression(e, f, v)
        else
            stdout.print(protobufExpression.toString())
            runtime.fail("invalid proto expression type")

def matchArmFromProtobuf(protobufMatchArm: Dyn): wyb_ast.MatchArm
    val v = protobufMatchArm.getVariable()
    val p = protobufMatchArm.getPath()
    val e = expressionFromProtobuf(protobufMatchArm.getExpression())
    wyb_ast.MatchArm(v, p, e)

def compileExpression(e: wyb_ast.Expression): String
    val r = rename.visitExpression(e)
    emit_js.visitExpression(r)


def compile(wyb: Dyn): Unit
    stdout.print("const FFI_JAVA_PLATFORM_STUB = require(process.env.WYVERN_HOME + \"/backend/stdlib/support/hack_java_ffi\");\n")
    def importLoop(i: Int, c: Int): Unit
        if (i < c)
            val imp = wyb.getImports(i)
            val p: String = imp.getPath()
            val n: String = imp.getName()
            // Undesirable coupling with rename?
            stdout.print("const " + rename.renameVariable("FFI_" + n) + " = require(process.env.WYVERN_HOME + \"/backend/" + util.replace(p, ".", "/") + "\");")
            stdout.println()
            importLoop(i + 1, c)
    val c: Int = wyb.getImportsCount()
    importLoop(0, c)

    def moduleLoop(i: Int): Unit
        val m = wyb.getModules(i)
        val e = expressionFromProtobuf(m.getValueModule().getExpression())
        val p = "MOD$" + m.getPath()
        // Undesirable coupling with rename?
        stdout.print("let " + rename.renameVariable(p) + " = " + compileExpression(e) + ";")
        if (i > 0)
            moduleLoop(i - 1)
    val m: Int = wyb.getModulesCount()
    moduleLoop(m - 1)

val filename = BackendSupport.getFirstCommandLineArg()
val wyb = BackendSupport.loadBytecode(filename)
compile(wyb)
